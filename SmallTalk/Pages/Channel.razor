@page "/channels/{ChannelName}"
@using EventAggregator.Blazor;
@using Markdig;
@using Markdown.ColorCode;
@using MoreLinq;
@using SmallTalk.Data;
@using SmallTalk.Data.Schema;
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IEventAggregator EventAggregator
@inject IJSRuntime JSRuntime
@inject IMessageDateRepository MessageDateRepository
@inject SmallTalkDataContext SmallTalkDataContext
@implements IHandle<MessagePublishedEvent>

<PageTitle>smalltalk #@ChannelName</PageTitle>

<div class="content-stack stack">

    <h1 class="title">#@ChannelName</h1>

    <div id="@ScrollableId" class="scrollable-content">

        <div class="centered-content">
            @foreach (var messageDay in Messages ?? Array.Empty<IEnumerable<IEnumerable<IEnumerable<Message>>>>())
            {
                <div class="date-divider">@messageDay.First().First().First().WriteTime.ToString("D")</div>

                foreach (var messageStack in messageDay)
                {
                    var user = Users[messageStack.First().First().Author];

                    <div class="message-group">

                        <div class="header message-row">
                            <div class="margin-column">
                                <AvatarView User=@user />
                            </div>
                            <div class="content-column">
                                <div class="message-stack-title">
                                    <div class="username">@user.DisplayName</div>
                                    <div class="timestamp">@($"{messageStack.First().First().WriteTime:h:mm tt}")</div>
                                </div>
                            </div>
                        </div>

                        @foreach(var messageVersions in messageStack)
                        {
                            var message = messageVersions.Last();

                            var messageDeleted = string.IsNullOrWhiteSpace(message.Content) && !message.Attachments.Any();

                            <div tabindex="0" class="message-stack @(messageVersions.First().WriteTime > LastViewTime ? "incoming" : "")">
                                <div class="toolbar">
                                    <div class="toolbox">
                                        @if (!messageDeleted)
                                        {
                                            <button class="tiny-button" title="Quote" @onclick="() => QuoteMessageAsync(message)">
                                                <span class="quote-icon">&OpenCurlyDoubleQuote;</span>
                                            </button>
                                        }

                                        @if (message.Author == User.Email)
                                        {
                                            @if (!messageDeleted)
                                            {
                                                    @*<a href="#">😄</a>
                                                    <a href="#"><span class="glyphicon glyphicon-share"></span></a>*@
                                                    <button class="tiny-button" title="Delete" @onclick="() => DeleteMessageAsync(messageVersions)">
                                                        <span class="glyphicon glyphicon-trash"></span>
                                                    </button>
                                                    <button class="tiny-button" title="Edit" @onclick="() => EditMessageAsync(messageVersions)">
                                                        <span class="glyphicon glyphicon-pencil"></span>
                                                    </button>
                                            }
                                            else
                                            {
                                                @*<a href="#">😄</a>
                                                <a href="#"><span class="glyphicon glyphicon-share"></span></a>*@
                                                <button class="tiny-button" title="Undo" @onclick="() => UndoDeleteMessageAsync(messageVersions)">
                                                    <span class="glyphicon glyphicon-repeat flip-horizontal"></span>
                                                </button>
                                            }
                                        }
                                    </div>
                                </div>
                                <div class="message-row">
                                    <div class="margin-column">
                                        <div class="timestamp">@*@($"{message.WriteTime:HH:mm}")*@</div>
                                    </div>
                                    <div class="content-column">
                                        @if (messageDeleted)
                                        {
                                            <p class="subtle">message deleted</p>
                                        }
                                        else if (!string.IsNullOrWhiteSpace(message.Content))
                                        {
                                            var markdown = messageVersions.Last().Content ?? string.Empty;

                                            @if (messageVersions.Count() > 1)
                                            {
                                                markdown += "\r\n<span class='subtle'>(edited)</span>";
                                            }

                                            @((MarkupString)Markdown.ToHtml(markdown, markdownPipeline))                                                
                                        }

                                        @foreach (var attachment in message.Attachments)
                                        {
                                            if (IsImageType(attachment.ContentType))
                                            {
                                                <a href="@attachment.Url" class="image-tile" target="_blank">
                                                    <img class="image-tile" src="@attachment.Url" />
                                                </a>
                                            }
                                            else
                                            {
                                                <a class="button" href="@attachment.Url" download>
                                                    <span class="glyphicon glyphicon-file"></span>
                                                    <span>@attachment.Label</span>
                                                    <span class="subtle">@attachment.ContentType</span>
                                                    <span class="subtle">@FormatFileSize(attachment.SizeBytes)</span>
                                                    <span class="glyphicon glyphicon-cloud-download"></span>
                                                </a>                                                
                                            }
                                        }
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
            }
        </div>
    </div>
    
    <MessageEditor @ref="messageEditor" ChannelName=@ChannelName User=@User />

</div>

@code
{
    MarkdownPipeline markdownPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .UseColorCode()
        .Build();

    MessageEditor messageEditor;

    bool scrollToBottomPending;

    [Parameter]
    public string ChannelName { get; set; }

    public string ScrollableId { get; set; } = $"{new Random().Next()}";

    public DateTime LastViewTime { get; set; } = DateTime.UtcNow;

    IReadOnlyDictionary<string, User> Users { get; set; }

    IEnumerable<IEnumerable<IEnumerable<IEnumerable<Message>>>> Messages { get; set; }

    User User { get; set; }

    protected override async Task OnInitializedAsync()
    {
        EventAggregator.Subscribe(this);
    }

    protected override async Task OnParametersSetAsync()
    {
        var authenticationState = await AuthenticationStateProvider.GetAuthenticationStateAsync();

        var user = authenticationState.User;

        var users = (await SmallTalkDataContext.Users.Get()).ToDictionary(u => u.Email, u => u);

        User = users[user.Identity.Name];

        await LoadMessagesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || scrollToBottomPending)
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", ScrollableId);

            scrollToBottomPending = false;
        }

        LastViewTime = DateTime.UtcNow;
    }

    public async Task HandleAsync(MessagePublishedEvent messagePublishedEvent)
    {
        await InvokeAsync(async () => await UpdateMessagesAsync());

        scrollToBottomPending = !messagePublishedEvent.WasEdit;
    }

    async Task UpdateMessagesAsync()
    {
        await LoadMessagesAsync();

        StateHasChanged();
    }

    async Task LoadMessagesAsync()
    {
        Users = (await SmallTalkDataContext.Users.Get()).ToDictionary(u => u.Email, u => u);

        var messages = new List<Message>();

        await foreach (var date in MessageDateRepository.EnumerateDatesAsync(channel: ChannelName))
        {
            await foreach (var message in MessageDateRepository.EnumerateMessagesAsync(channel: ChannelName, date: date))
            {
                messages.Add(message with 
                {
                    WriteTime = message.WriteTime.ToLocalTime(), 
                });
            }
        }

        Messages = messages
            .GroupBy(m => m.MessageId)
            .GroupBy(v => v.First().WriteTime.Date)
            .Select(g => g.GroupAdjacent(v => v.First().Author));
    }

    async Task EditMessageAsync(IEnumerable<Message> messageVersions)
    {
        await messageEditor.EditMessageAsync(messageVersions.Last() with 
        { 
            WriteTime = messageVersions.First().WriteTime.ToUniversalTime() 
        });
    }

    async Task DeleteMessageAsync(IEnumerable<Message> messageVersions)
    {
        var message = messageVersions.First();

        await MessageDateRepository.AppendMessageAsync(
            channel: message.Channel,
            date: message.WriteTime.Date,
            message: new Message(
                MessageId: message.MessageId,
                Channel: message.Channel,
                Author: message.Author,
                WriteTime: DateTime.UtcNow,
                ParentMessageDate: message.ParentMessageDate,
                ParentMessageId: message.ParentMessageId,
                Content: string.Empty,
                Attachments: Array.Empty<Attachment>(),
                Reactions: Array.Empty<Reaction>()));

        await EventAggregator.PublishAsync(new MessagePublishedEvent(WasEdit: true));
    }

    async Task UndoDeleteMessageAsync(IEnumerable<Message> messageVersions)
    {
        var message = messageVersions
            .Reverse()
            .SkipWhile(m => string.IsNullOrWhiteSpace(m.Content))
            .First();

        await MessageDateRepository.AppendMessageAsync(
            channel: ChannelName,
            date: message.WriteTime.Date,
            message: new Message(
                MessageId: message.MessageId,
                Channel: message.Channel,
                Author: message.Author,
                WriteTime: DateTime.UtcNow,
                ParentMessageDate: message.ParentMessageDate,
                ParentMessageId: message.ParentMessageId,
                Content: message.Content,
                Attachments: Array.Empty<Attachment>(),
                Reactions: Array.Empty<Reaction>()));

        await EventAggregator.PublishAsync(new MessagePublishedEvent(WasEdit: true));
    }

    async Task QuoteMessageAsync(Message message)
    {
        var lines = message.Content.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);

        await messageEditor.SetEditorTextAsync(string.Join("\n", lines.Select(l => $"> {l}")) + "\r\n\r\n\r\n");
    }

    string FormatFileSize(long length)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        double len = length;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }

        // Adjust the format string to your preferences. For example "{0:0.#}{1}" would
        // show a single decimal place, and no space.
        return string.Format("{0:0.##} {1}", len, sizes[order]);
    }

    bool IsImageType(string contentType)
    {
        switch (contentType)
        {
            case "image/png":
            case "image/gif":
            case "image/jpeg":
                return true;

            default: return false;
        }
    }
}