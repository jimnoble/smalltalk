@page "/channels/{ChannelName}"
@using EventAggregator.Blazor;
@using Markdig;
@using MoreLinq;
@using SmallTalk.Data;
@using SmallTalk.Data.Schema;
@inject IEventAggregator EventAggregator
@inject IJSRuntime JSRuntime
@inject IMessageDateRepository MessageDateRepository
@inject SmallTalkDataContext SmallTalkDataContext
@implements IHandle<MessagePublishedEvent>

<PageTitle>Smalltalk #@ChannelName</PageTitle>

<div class="content-stack stack">

    <div id="@ScrollableId" class="scrollable-content">

        <h1>#@ChannelName</h1>

        @foreach (var messageDay in Messages ?? Array.Empty<IEnumerable<IEnumerable<IEnumerable<Message>>>>())
        {
            <div class="date-divider">@messageDay.First().First().First().WriteTime.ToString("D")</div>

            foreach (var messageStack in messageDay)
            {
                var user = Users[messageStack.First().First().Author];

                <div class="message-group">

                    <div class="header message-row">
                        <div class="margin-column">
                            @if (string.IsNullOrWhiteSpace(user.AvatarUrl))
                            {
                                <div class="avatar" style="background-color: @(user.AvatarColor)">@user.DisplayName.Substring(0, 1)</div>
                            }
                            else
                            {
                                <div class="avatar" style="background: url(@(user.AvatarUrl)) no-repeat center center; background-size: auto 100%; background-color: @(user.AvatarColor)"></div>
                            }
                        </div>
                        <div class="content-column">
                            <div class="message-stack-title">
                                <div class="username">@user.DisplayName</div>
                                <div class="timestamp">@($"{messageStack.First().First().WriteTime:HH:mm}")</div>
                            </div>
                        </div>
                    </div>

                    @foreach(var messageVersions in messageStack)
                    {
                        var message = messageVersions.Last();

                        <div tabindex="0" class="message-stack @(messageVersions.First().WriteTime > LastViewTime ? "incoming" : "")">
                            <div class="toolbar">
                                <div class="toolbox">
                                    @if (!string.IsNullOrWhiteSpace(message.Content))
                                    {
                                            @*<a href="#">😄</a>
                                            <a href="#"><span class="glyphicon glyphicon-share"></span></a>*@
                                            <button @onclick="() => DeleteMessageAsync(messageVersions)"><span class="glyphicon glyphicon-trash"></span></button>
                                            <button @onclick="() => EditMessageAsync(messageVersions)"><span class="glyphicon glyphicon-pencil"></span></button>
                                    }
                                    else
                                    {
                                        @*<a href="#">😄</a>
                                        <a href="#"><span class="glyphicon glyphicon-share"></span></a>*@
                                        <button @onclick="() => UndoDeleteMessageAsync(messageVersions)"><span class="glyphicon glyphicon-repeat flip-horizontal"></span></button>
                                    }
                                </div>
                            </div>
                            <div class="message-row">
                                <div class="margin-column">
                                    <div class="timestamp">@*@($"{message.WriteTime:HH:mm}")*@</div>
                                </div>
                                <div class="content-column">
                                    @if (string.IsNullOrWhiteSpace(message.Content))
                                    {
                                        <p class="subtle">message deleted</p>
                                    }
                                    else
                                    {
                                        <p>@((MarkupString)Markdown.ToHtml(messageVersions.Last().Content ?? string.Empty))</p>                                        
                                    }
                                </div>
                            </div>
                        </div>
                    }

                </div>
            }
        }
    </div>
    
    <MessageEditor @ref="messageEditor" OnSubmit=MessageSubmittedAsync />

</div>

@code
{
    MessageEditor messageEditor;

    bool scrollToBottomPending;

    [Parameter]
    public string ChannelName { get; set; }

    public string ScrollableId { get; set; } = $"{new Random().Next()}";

    public DateTime LastViewTime { get; set; } = DateTime.UtcNow;

    IReadOnlyDictionary<string, User> Users { get; set; }

    IEnumerable<IEnumerable<IEnumerable<IEnumerable<Message>>>> Messages { get; set; }

    protected override async Task OnInitializedAsync()
    {
        EventAggregator.Subscribe(this);
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadMessagesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || scrollToBottomPending)
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", ScrollableId);

            scrollToBottomPending = false;
        }

        LastViewTime = DateTime.UtcNow;
    }

    public async Task HandleAsync(MessagePublishedEvent messagePublishedEvent)
    {
        await InvokeAsync(async () => await UpdateMessagesAsync());
    }

    async Task UpdateMessagesAsync()
    {
        await LoadMessagesAsync();

        StateHasChanged();
    }

    async Task MessageSubmittedAsync()
    {
        scrollToBottomPending = true;        
    }

    async Task LoadMessagesAsync()
    {
        Users = (await SmallTalkDataContext.Users.Get()).ToDictionary(u => u.Email, u => u);

        var messages = new List<Message>();

        await foreach (var date in MessageDateRepository.EnumerateDatesAsync(channel: "alchemy"))
        {
            await foreach (var message in MessageDateRepository.EnumerateMessagesAsync(channel: "alchemy", date: date))
            {
                messages.Add(message);
            }
        }

        Messages = messages
            .GroupBy(m => m.MessageId)
            .GroupBy(v => v.First().WriteTime.Date)
            .Select(g => g.GroupAdjacent(v => v.First().Author));
    }

    async Task EditMessageAsync(IEnumerable<Message> messageVersions)
    {
        await messageEditor.FocusEditorAsync();

        messageEditor.EditMessage(messageVersions.Last() with { WriteTime  = messageVersions.First().WriteTime });
    }

    async Task DeleteMessageAsync(IEnumerable<Message> messageVersions)
    {
        var message = messageVersions.First();

        await MessageDateRepository.AppendMessageAsync(
            channel: message.Channel,
            date: message.WriteTime.Date,
            message: new Message(
                MessageId: message.MessageId,
                Channel: message.Channel,
                Author: message.Author,
                WriteTime: DateTime.UtcNow,
                ParentMessageDate: message.ParentMessageDate,
                ParentMessageId: message.ParentMessageId,
                Content: string.Empty,
                Attachments: Array.Empty<Attachment>(),
                Reactions: Array.Empty<Reaction>()));

        UpdateMessagesAsync();
    }

    async Task UndoDeleteMessageAsync(IEnumerable<Message> messageVersions)
    {
        var message = messageVersions
            .Reverse()
            .SkipWhile(m => string.IsNullOrWhiteSpace(m.Content))
            .First();

        await MessageDateRepository.AppendMessageAsync(
            channel: "alchemy",
            date: message.WriteTime.Date,
            message: new Message(
                MessageId: message.MessageId,
                Channel: message.Channel,
                Author: message.Author,
                WriteTime: DateTime.UtcNow,
                ParentMessageDate: message.ParentMessageDate,
                ParentMessageId: message.ParentMessageId,
                Content: message.Content,
                Attachments: Array.Empty<Attachment>(),
                Reactions: Array.Empty<Reaction>()));

        UpdateMessagesAsync();
    }
}