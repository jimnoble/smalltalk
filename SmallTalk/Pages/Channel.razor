@page "/channels/{ChannelName}"
@using EventAggregator.Blazor;
@using Markdig;
@using MoreLinq;
@using SmallTalk.Data;
@using SmallTalk.Data.Schema;
@inject IJSRuntime JSRuntime
@inject IMessageDateRepository MessageDateRepository
@inject SmallTalkDataContext SmallTalkDataContext
@inject IEventAggregator EventAggregator
@implements IHandle<MessagePublishedEvent>

<PageTitle>Smalltalk #@ChannelName</PageTitle>

<div class="content-stack stack">

    <div id="@ScrollableId" class="scrollable-content">

        <h1>#@ChannelName</h1>

        @foreach (var messageDay in Messages ?? Array.Empty<IEnumerable<IEnumerable<Message>>>())
        {
            <div class="date-divider">@messageDay.First().First().WriteTime.ToString("D")</div>

            foreach (var messageStack in messageDay)
            {
                var user = Users[messageStack.First().Author];

                <div class="message-group">

                    <div class="header message-row">
                        <div class="margin-column">
                            @if (string.IsNullOrWhiteSpace(user.AvatarUrl))
                            {
                                <div class="avatar" style="background-color: @(user.AvatarColor)">@user.DisplayName.Substring(0, 1)</div>
                            }
                            else
                            {
                                <div class="avatar" style="background: url(@(user.AvatarUrl)) no-repeat center center; background-size: auto 100%; background-color: @(user.AvatarColor)"></div>
                            }
                        </div>
                        <div class="content-column">
                            <div class="message-stack-title">
                                <div class="username">@user.DisplayName</div>
                                <div class="timestamp">@($"{messageStack.First().WriteTime:HH:mm}")</div>
                            </div>
                        </div>
                    </div>

                    @foreach(var message in messageStack)
                    {
                        <div tabindex="0" class="message-stack @(message.WriteTime > LastViewTime ? "incoming" : "")">
                            <div class="toolbar">
                                <div class="toolbox">
                                    <a href="#">😄</a>
                                    <a href="#"><span class="glyphicon glyphicon-share"></span></a>
                                    <button @onclick="() => DeleteMessageAsync(message)"><span class="glyphicon glyphicon-trash"></span></button>
                                    <button @onclick="() => EditMessage(message)"><span class="glyphicon glyphicon-pencil"></span></button>
                                </div>
                            </div>
                            <div class="message-row">
                                <div class="margin-column">
                                    <div class="timestamp">@*@($"{message.WriteTime:HH:mm}")*@</div>
                                </div>
                                <div class="content-column">
                                    <p>@((MarkupString)Markdown.ToHtml(message.Content ?? string.Empty))</p>
                                </div>
                            </div>
                        </div>
                    }

                </div>
            }
        }
    </div>
    
    <MessageEditor @ref="messageEditor" OnSubmit=MessageSubmittedAsync />

</div>

@code
{
    MessageEditor messageEditor;

    bool scrollToBottomPending;

    [Parameter]
    public string ChannelName { get; set; }

    public string ScrollableId { get; set; } = $"{new Random().Next()}";

    public DateTime LastViewTime { get; set; } = DateTime.UtcNow;

    IReadOnlyDictionary<string, User> Users { get; set; }

    IEnumerable<IEnumerable<IEnumerable<Message>>> Messages { get; set; }

    protected override async Task OnInitializedAsync()
    {
        EventAggregator.Subscribe(this);
    }

    protected override async Task OnParametersSetAsync()
    {
        await LoadMessagesAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || scrollToBottomPending)
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", ScrollableId);

            scrollToBottomPending = false;
        }

        LastViewTime = DateTime.UtcNow;
    }

    public async Task HandleAsync(MessagePublishedEvent messagePublishedEvent)
    {
        await InvokeAsync(async () => await UpdateMessagesAsync());
    }

    async Task UpdateMessagesAsync()
    {
        await LoadMessagesAsync();

        StateHasChanged();
    }

    async Task MessageSubmittedAsync()
    {
        scrollToBottomPending = true;        
    }

    async Task LoadMessagesAsync()
    {
        Users = (await SmallTalkDataContext.Users.Get()).ToDictionary(u => u.Email, u => u);

        var messages = new List<Message>();

        await foreach (var date in MessageDateRepository.EnumerateDatesAsync(channel: "alchemy"))
        {
            await foreach (var message in MessageDateRepository.EnumerateMessagesAsync(channel: "alchemy", date: date))
            {
                messages.Add(message);
            }
        }

        Messages = messages.GroupBy(m => m.WriteTime.Date).Select(g => g.GroupAdjacent(m => m.Author));
    }

    void EditMessage(Message message)
    {
        messageEditor.EditMessage(message);
    }

    async Task DeleteMessageAsync(Message message)
    {
        //MessageDateRepository.
    }
}